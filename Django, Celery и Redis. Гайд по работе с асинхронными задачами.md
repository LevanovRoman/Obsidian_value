https://proglib.io/p/django-celery-i-redis-gayd-po-rabote-s-asinhronnymi-zadachami-2022-08-22

Celery — это **распределенная очередь задач** для систем UNIX. Она позволяет вам выгрузить работу из вашего приложения на Python. Как только вы интегрируете Celery в свое приложение, вы можете отправлять трудоемкие задачи в очередь задач Celery. Таким образом, ваше веб-приложение может продолжать быстро реагировать на запросы пользователей, в то время как Celery асинхронно выполняет операции, требующие больших затрат в фоновом режиме.
## Основы Python Celery

[Celery](https://docs.celeryq.dev/en/stable/index.html) — это распределенная [очередь](https://realpython.com/queue-in-python/) задач, которая может собирать, записывать, планировать и выполнять задачи вне вашей основной программы.
Чтобы получать задачи от вашей программы и отправлять результаты в серверную часть, Celery требуется [брокер сообщений](https://en.wikipedia.org/wiki/Message_broker) для связи. **Redis** и **RabbitMQ** — это два брокера сообщений, которые разработчики часто используют вместе с Celery.
Если вы хотите отслеживать результаты выполнения вашей задачи, вам также необходимо настроить **серверную** **базу данных результатов**.
Если вы хотите отслеживать результаты выполнения вашей задачи, вам также необходимо настроить **серверную** **базу данных результатов**.

**Примечание**
Подключать Celery к серверу результатов необязательно. Как только вы поручите Celery запустить задачу, она будет выполнять свои обязанности независимо от того, отслеживаете вы результат задачи или нет. Однако часто бывает полезно вести учет всех результатов задачи, если вы распределяете задачи по нескольким очередям. Чтобы сохранить информацию о результатах задачи, вам нужна серверная часть базы данных.

Вы можете использовать [множество различных баз данных](https://docs.celeryq.dev/en/latest/userguide/configuration.html#std-setting-result_backend) для отслеживания результатов задачи Celery. В этом руководстве вы будете работать с [Redis](https://realpython.com/python-redis/) как с брокером сообщений, так и с серверной частью результатов. Используя Redis, вы ограничиваете зависимости, которые необходимо установить, поскольку он может выполнять обе роли.

Вы не будете выполнять какую-либо работу с записанными результатами задачи в рамках этого туториала. Однако в качестве следующего шага вы можете проверить результаты с помощью интерфейса командной строки (CLI) Redis или вывести информацию на специальную страницу в вашем проекте Django.
## Зачем использовать Celery?

Есть две основные причины, по которым большинство разработчиков хотят начать использовать Celery:

1. **Перенос работы** из вашего приложения в распределенные процессы, которые могут работать независимо от вашего приложения.
2. **Планирование выполнения задач** в определенное время, иногда как повторяющиеся события.

Celery — отличный выбор для обоих этих вариантов использования. Он определяет себя как «очередь задач, ориентированных на обработку в реальном времени, а также поддерживающих планирование задач».
Несмотря на то, что обе эти функции являются частью Celery, к ним часто обращаются отдельно:
1. **Рабочие процессы Celery** — это рабочие процессы, которые выполняют задачи независимо друг от друга и вне контекста вашего основного сервиса.
2. **Celery beat** — это планировщик, который определяет, когда запускать задачи. Вы также можете использовать его для планирования периодических задач.
Рабочие процессы составляют основу Celery. Даже если вы хотите запланировать повторяющиеся задачи с помощью Celery beat, процесс Celery примет ваши инструкции и выполнит их в запланированное время. Celery beat добавляет к этому миксу планировщик для рабочих процессов Celery.

В этом туториале вы также узнаете, как интегрировать Celery с Django для асинхронного выполнения операций из основного потока выполнения вашего приложения с помощью рабочих процессов Celery.
## Как вы можете использовать Celery для своего приложения Django?

Celery полезен для работы веб-приложений и пользуется заслуженной популярностью, так как вы можете эффективно справляться с некоторыми повседневными ситуациями в веб-разработке, например:

1. **Отправление по электронной почте**: Вы можете отправить подтверждение по электронной почте, электронное письмо для сброса пароля или подтверждение отправки формы. Отправка электронных писем может занять некоторое время и замедлить работу вашего приложения, если пользователей много.
2. **Обработка изображений**. Возможно, вы захотите изменить размер изображений аватаров, загружаемых пользователями, или применить какую-нибудь кодировку ко всем изображениям, которыми пользователи могут делиться на вашей платформе. Обработка изображений часто является ресурсоемкой задачей, которая может замедлить работу вашего веб-приложения, если вы обслуживаете большое сообщество пользователей.
3. **Обработка текста.** Если вы разрешаете пользователям добавлять данные в ваше приложение, вы можете отслеживать то, что они вводят. Например, вы можете проверить наличие ненормативной лексики в комментариях или перевести пользовательский текст на другой язык. Обработка всей этой работы в контексте вашего веб-приложения может значительно снизить производительность.
4. **Вызовы API и другие веб-запросы.** Если вам нужно сделать веб-запросы для предоставления услуги, предлагаемой вашим приложением, вы можете быстро столкнуться с непредвиденным временем ожидания. Это верно как для запросов API с ограниченной скоростью, так и для других задач, таких как [парсинг веб-страниц](https://realpython.com/beautiful-soup-web-scraper-python/). Часто лучше передать эти запросы другому процессу.
5. **Анализ данных**. Обработка данных, как известно, требует больших ресурсов. Если ваше веб-приложение анализирует данные для ваших пользователей, вы быстро увидите, что ваше приложение перестает отвечать на запросы, если вы выполняете всю работу прямо в Django.
6. **Запуск модели машинного обучения**. Как и в случае с анализом данных, ожидание результатов операций машинного обучения может занять некоторое время. Вместо того чтобы позволить вашим пользователям ждать завершения вычислений, вы можете переложить эту работу на Celery, чтобы они могли продолжать пользоваться вашим веб-приложением, пока результаты не будут получены.
7. **Генерация отчетов**. Если вы используете приложение, которое позволяет пользователям создавать отчеты на основе предоставленных ими данных, вы заметите, что создание PDF-файлов не происходит мгновенно. Будет лучше, если вы позволите Celery обрабатывать это в фоновом режиме вместо того, чтобы замораживать работу своего веб-приложения, пока отчет не будет готов для загрузки.

Основная настройка для всех этих различных вариантов использования будет одинаковой. Как только вы поймете, как передать процессы, требующие больших вычислительных или временных ресурсов в распределенную очередь задач, вы освободите Django для обработки цикла [HTTP-запрос-ответ](https://realpython.com/python-web-applications/#review-the-http-request-response-cycle).

В этом руководстве вы разберетесь со сценарием отправки электронной почты. Вы начнете с проекта, в котором Django обрабатывает отправку электронной почты синхронно. Вы увидите, как это «заморозит» ваше приложение Django. Затем вы узнаете, как перенести задачу в Celery, чтобы вы могли проверить, насколько это ускорить работу вашего веб-приложения.



