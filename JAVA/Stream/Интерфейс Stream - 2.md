## Преобразование данных

Также у класса `Stream<T>` есть метод, который позволяет преобразовать данные из одного типа в другой. Этот метод называется `map()`.

Он тоже возвращает поток `Stream<R>`, но уже с элементами нового типа. В качестве параметра в метод `map()` нужно передать функцию, которая преобразовывает один тип данных в другой.

Примеры:

```java
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
Stream<String> stream2 = stream.map((x) -> String.valueOf(x));
```

Преобразовываем поток `Integer` в поток `String`

Функция, которую передали в метод `map()` в качестве параметра, принимает число `x`, а в качестве результата возвращает строку. Можно, кстати, записать этот код короче:

```java
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
Stream<String> stream2 = stream.map(String::valueOf);
```

Преобразовываем поток `Integer` в поток `String`

**Преобразование строки в число**

Аналогично можно написать код и для преобразования строки в число — тоже ничего сложного:

```java
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);
Stream<String> stream2 = stream.map(String::valueOf);
Stream<Integer> stream3 = stream2.map(Integer::parseInt);
```

Преобразовываем поток `String` в поток `Integer`

**Преобразование строки в `URI`**

Операции по преобразованию данных могут быть большими и тяжелыми. Допустим, мы хотим преобразовать коллекцию строк в объекты URI. Это очень легко сделать, ведь URI принимает строку в качестве параметра конструктора

```java
ArrayList<String> list = new ArrayList<String>();
list.add("https://google.com");
list.add("https://linkedin.com");
list.add("https://yandex.com");

Stream<URI> stream = list.stream().map( URI::new );
```

Преобразовываем поток `String` в поток `URI`

Мы создали коллекцию, записали в нее 3 ссылки на сайты в интернете. Затем получили у коллекции объект `Stream<String>` и у него — объект `Stream<URI>`. А в метод map передали ссылку на метод, который будет использоваться для преобразования из String в URI.

Этот метод (конструктор) должен принимать в качестве параметра тип `String`. Все вроде бы идеально...

---

## 2. Исключения

Код выше должен работать, но он работать не будет — программа не скомпилируется. И не потому, что мы где-то сделали ошибку, а потому, что ее сделали разработчики Java.

Когда-то давно им пришла в голову замечательная идея — добавить в конструктор(!) класса `URI` checked-исключение `URISyntaxException`. А такие исключения нужно обязательно заворачивать в `try-catch`.

Поэтому последняя строка нашего кода будет выглядеть вот так:

```java
Stream<URI> stream = list.stream().map(str ->
{
  try
  {
     return new URI(str);
  }
  catch (URISyntaxException e)
  {
     e.printStackTrace();
     return null;
  }
});
```

Что вам сказать? Нужно дважды подумать, прежде чем использовать checked-исключения. И трижды, прежде чем использовать их в конструкторе.
## Проверка

Думаю, вам уже скучно изучать, как конструировать цепочки потоков данных. Хочется наконец-то с этими данными что-то делать.

У класса `Stream` есть три стандартных метода, которые не конструируют потоки, а проверяют, что за данные находятся в этих потоках. Это методы: `anyMatch()`, `allMatch()` и `noneMatch()`.

**Метод `boolean anyMatch(правило)`**

Этот метод проверяет, что в потоке есть хотя бы один элемент, который удовлетворяет правилу, которое передается в метод. Если такой элемент есть, метод возвращает `true`, иначе — `false`.

Примеры

|Код|Примечание|
|---|---|
|```java<br>Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);<br>boolean result = stream.anyMatch(x -> x > 0);<br>```|```<br><br>true<br>```|
|```java<br>Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);<br>boolean result = stream.anyMatch(x -> x > 0);<br>```|```<br><br>true<br>```|
|```java<br>Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);<br>boolean result = stream.filter(x -> x < 0).anyMatch(x -> x > 0);<br>```|```<br><br>false<br>```|

В последнем примере мы сначала отфильтровываем (пропускаем через фильтр) все элементы меньше нуля, а затем уже среди них проводим проверку, есть ли хотя бы один элемент больше нуля. Ясное дело, таких элементов там уже нет.

**Метод boolean allMatch(правило)**

Этот метод проверяет, что все элементы в потоке соответствуют правилу. Правило передается в метод в качестве параметра:

|Код|Примечание|
|---|---|
|```java<br>Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);<br>boolean result = stream.allMatch(x -> x > 0);<br>```|```<br>true<br>```<br><br>(все элементы больше нуля)|
|```java<br>Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);<br>boolean result = stream.allMatch(x -> x > 0);<br>```|```<br>false<br>```<br><br>(есть элементы меньше или равны нулю)|
|```java<br>Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);<br>boolean result = stream.filter(x -> x < 0).allMatch(x -> x < 0);<br>```|```<br>true<br>```<br><br>(отфильтровали элементы меньше нуля)|

В последнем примере мы сначала пропускаем через фильтр только элементы меньше нуля, а потом уже среди них выполняем проверку, что все элементы меньше нуля. Проверка проходит успешно.

**Метод boolean noneMatch(правило)**

Метод `noneMatch()` проверяет, что в потоке нет ни одного элемента, который соответствует переданному правилу. Противоположный по смыслу метод к методу `anyMatch()`.

|Код|Примечание|
|---|---|
|```java<br>Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);<br>boolean result = stream.noneMatch(x -> x > 0);<br>```|```<br><br>false<br>```|
|```java<br>Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);<br>boolean result = stream.noneMatch(x -> x > 0);<br>```|```<br><br>false<br>```|
|```java<br>Stream<Integer> stream = Stream.of(1, -2, 3, -4, 5);<br>boolean result = stream.filter(x -> x < 0).noneMatch(x -> x > 0);<br>```|```<br><br>true<br>```|

## Поиск элементов

Вернемся к классу `Stream`. У класса `Stream` есть еще 4 метода, которые позволяют искать элементы в потоке. Это методы `findFirst()`, `findAny()`, `min()` и `max()`.

**Метод `Optional<T> findFirst()`**

Метод `findFirst()` просто возвращает первый элемент из потока и все — на этом его работа завершается.

Более интересно, что метод возвращает не объект типа `T`, а обертку над ним — объект типа `Optional<T>`. Это сделано для того, чтобы никогда не сталкиваться с ситуацией, когда метод не находит объект и возвращает `null`.

Пример:

```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "Привет", "как", "дела?");
String str = list.stream().findFirst().get(); // Привет
```

Давайте для большей ясности распишем последнюю строку в несколько строк:

```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "Привет", "как", "дела?");

Stream<String> stream = list.stream();
Optional<String> result = stream.findFirst();
String str = result.get(); // Привет
```

Последний метод `get()` — это просто вытаскивание значения, которое хранится внутри объекта `Optional`.

**Метод `Optional<T> findAny()`**

Метод `findAny()` возвращает любой элемент из потока и на этом завершается. Этот метод — это аналог метода `findFirst()`, только для потоков, которые обрабатываются параллельно.

При параллельной обработке потоков может случиться такая ситуация, что в какой-то части потока элемент уже найден, но пока еще не понятно, будет он первым или нет.

Если элементов, которые прошли все фильтры, много и для программиста принципиально получить именно первый из них, следует вызывать метод `findFirst()`. Если программист знает, что реально через все фильтры пройдет 0 или 1 элемент, тогда достаточно просто вызвать `findAny()` — так будет быстрее.

**Метод `Optional<T> min(Comparator<T>)`**

Метод `min()` сравнивает все элементы потока с помощью объекта `comparator` и возвращает минимальный элемент. Удобнее всего задать объект-компаратор с помощью лямбда-функции.

Пример — поиск строки с минимальной длиной:

```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "Привет", "как", "дела?");
String min = list.stream().min( (s1, s2)-> s1.length()-s2.length() ).get();
```

**Метод `Optional<T> max(Comparator<T>)`**

Метод `max()` сравнивает все элементы потока с помощью объекта `comparator` и возвращает максимальный элемент. Удобнее всего задать объект-компаратор с помощью лямбда-функции.

Пример — поиск строки с максимальной длиной:

```java
ArrayList<String> list = new ArrayList<String>();
Collections.addAll(list, "Привет", "как", "дела?");
String max = list.stream().max( (s1, s2)-> s1.length()-s2.length() ).get();
```

