1. **Arrays.toString()**.
2. **Arrays.sort()**.
3. **Arrays.equals()**
4. **Arrays.copyOf()**
5. **Arrays.copyOfRange()**
6. **Arrays.deepToString()**
7. **Arrays.deepEquals()**
8. **Arrays.fill()**
9. **Arrays.binarySearch()**

https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Arrays.html

Для работы с массивами в java есть специальный класс Arrays. Вот некоторые полезные методы, которые он предоставляет. 

Вначале класс нужно импортировать :

```java
import java.util.Arrays;
```

1. **Arrays.toString()**. 

Метод преобразует массив в строку. Полезен, прежде всего, для вывода массива на печать. Если попытаться напечатать массив напрямую, то мы получим вместо массива его шестнадцатеричный хеш-код:

```java
int[] array = {1, 2, 3, 4, 5}; 
System.out.println(array);       // [I@b800 - этот хеш-код будет изменяться при каждом запуске
```

Поэтому, для начала, массив нужно преобразовать в строку:

```java
int[] array = {1, 2, 3, 4, 5}; 
System.out.println(Arrays.toString(array));       // [1, 2, 3, 4, 5]
```

2. **Arrays.sort()**.

Этот метод сортирует массив или его часть.

```java
int[] array = {5, 10, 15, 4, 1};

Arrays.sort(array);
System.out.println(Arrays.toString(array)); // [1, 4, 5, 10, 15]
```

Можно отсортировать только часть массива, указав начальный и конечный индексы при вызове метода:

```java
int[] array = {5, 10, 15, 4, 1, 7, 23, 8, 11, 42};
Arrays.sort(array, 3, 7);
System.out.println(Arrays.toString(array));    // [5, 10, 15, 1, 4, 7, 23, 8, 11, 42]
```

В этом примере мы отсортировали только элементы массива с индексами от 3 до 6 (правая граница не входит в отрезок сортировки).

Обратите внимание: метод ничего не возвращает, а сортирует массив "на месте". Если попытаться присвоить результат работы метода какой-нибудь переменной, компилятор выдаст ошибку.

Можно сортировать и массивы из строк. В этом случае, сортировка производится в лексикографическом порядке.  

```java
String[] array = {"one", "two", "three", "four"};
Arrays.sort(array);
System.out.println(Arrays.toString(array));    // [four, one, three, two]
```

3. **Arrays.equals()**

Этот метод сравнивает два массива и возвращает true, если они равны, и false - в обратном случае.

```java
int[] numbers1 = {1, 2, 3};
int[] numbers2 = {1, 2, 3};

System.out.println(Arrays.equals(numbers1, numbers2));    // true

int[] numbers3 = {1, 2, 3, 4};

boolean result = Arrays.equals(numbers1, numbers3);
System.out.println(result);    // false

```

Особое внимание необходимо обратить, что сравнивать массивы необходимо именно с помощью статического метода класса, а не так, как мы сравнивали строки (с помощью метода экземпляра).

```java
int[] numbers1 = {1, 2, 3};
int[] numbers2 = {1, 2, 3};

System.out.println(number1.equals(numbers2));    // false
```

Так происходит потому, что массив является ссылочным типом данных, то есть, переменная содержит не сами данные, а только ссылку на них. В этом случае Java сравнивает между собой не данные, а ссылки на объекты. Поскольку объекты разные, то и результат сравнения получается false. 

4. **Arrays.copyOf()**

Метод возвращает копию массива. Метод получает в качестве аргументов массив, который нужно скопировать, и число элементов, которые нужно скопировать. Отсчёт ведётся с первого элемента массива.

```java
int[] numbers1 = {1, 2, 3, 4, 5};
int[] numbers2 = Arrays.copyOf(numbers1, 5);

System.out.println(Arrays.toString(numbers2));    // [1, 2, 3, 4, 5]


int[] numbers3 = Arrays.copyOf(numbers1, 3);

System.out.println(Arrays.toString(numbers3));    // [1, 2, 3]


```

Если нужно скопировать весь массив, можно передать в качестве аргумента его длину:

```java
int[] numbers1 = {1, 2, 3, 4, 5};
int[] numbers2 = Arrays.copyOf(numbers1, numbers1.length);

System.out.println(Arrays.toString(numbers2));    // [1, 2, 3, 4, 5]
```

Важно понимать разницу между приравниванием массивов друг другу и копированием:

```java
int[] numbers1 = {1, 2, 3, 4, 5};
int[] numbers2 = numbers1;
int[] numbers3 = Arrays.copyOf(numbers1, numbers1.length);

numbers1[3] = 1000;

System.out.println(Arrays.toString(numbers2));    // [1, 2, 3, 1000, 5]

System.out.println(Arrays.toString(numbers3));    // [1, 2, 3, 4, 5]

​
```

Так получается потому, что numbers1 и numbers2 ссылаются на один и тот же объект, а numbers1 и numbers3 - на разные. 

Таким образом, метод Arrays.copyOf() создаёт новый, независимый от оригинального, массив.

5. **Arrays.copyOfRange()**

Если нужно скопировать не массив целиком, а только его кусок, подойдёт метод Arrays.copyOfRange(). Этот метод получает на вход массив, а также стартовый и конечный индексы "куска", который нужно скопировать:

```java
int[] numbers1 = {2, 4, 6, 8, 10, 12, 14, 16};

int [] numbers2 = Arrays.copyOfRange(numbers1, 2, 5);
System.out.println(Arrays.toString(numbers2));    // [6, 8, 10]
```

Мы получили новый массив, вырезанный из первоначального, включая начальный индекс (2), но не включая конечный.

6. **Arrays.deepToString()**
Как нам получить правильное отображение двумерного массива?

Для этого у класса `Arrays` есть еще один специальный метод — `deepToString()`. Вызов его выглядит так:

```java
String str = Arrays.deepToString(имя);
```

В этот метод можно передать двумерный, одномерный, трехмерный и вообще массив любой размерности, и он всегда будет отображать элементы массива.  
**Обрати внимание:** метод `Arrays.deepToString()` не работает с одномерными массивами примитивов (например, `int[]`).

Примеры:

|   |   |
|---|---|
|```java<br>Integer[] array = {1, 2, 3};<br>String str = Arrays.deepToString(array);<br>```|Переменная `str` будет содержать строковое значение:<br><br>```<br>"[1, 2, 3]"<br>```|
|```java<br>int[][] array = { {1, 1}, {2, 2}, {3, 3} };<br>String str = Arrays.deepToString(array);<br>```|Переменная `str` будет содержать строковое значение:<br><br>```<br>"[[1, 1], [2, 2], [3, 3]]"<br>```|
|```java<br>int[][][] array = { {{1, 2, 3}, {1}}, {{}} };<br>String str = Arrays.deepToString(array);<br>```|Переменная `str` будет содержать строковое значение:<br><br>```<br>"[[[1, 2, 3], [1]], [[]]]"<br>```|

7. **Arrays.deepEquals()**

метод `Arrays.equals` для двумерных массивов будет работать неправильно: он работает с двумерным массивом как с одномерным, элементы которого — адреса одномерных массивов.

Поэтому, чтобы правильно сравнивать многомерные массивы (`n=1, 2, 3, ...`), придумали метод `Arrays.deepEquals()`. Выглядит его вызов так:

```java
Arrays.deepEquals(имя1, имя2)
```

Метод возвращает `true` (истина), если массивы равной длины и их элементы равны. Иначе возвращает `false` (ложь). Если элементы внутри массива — тоже массивы, для их сравнения используется метод `Arrays.deepEquals()` и т.д.

Примеры:

|   |   |
|---|---|
|```java<br>int[][] x1 = {{1, 2, 3}, {4, 5, 6}};<br>int[][] x2 = {{1, 2, 3}, {4, 5, 6}};<br>x1.equals(x2);<br>```|Метод `equals` у массивов банально сравнивает ссылки двух массивов.  <br>  <br>`false` (ссылки не равны)|
|```java<br>int[][] x1 = {{1, 2, 3}, {4, 5, 6}};<br>int[][] x2 = {{1, 2, 3}, {4, 5, 6}};<br>Arrays.equals(x1, x2);<br>```|Метод `Arrays.equals` сравнит `x1` и `x2` как одномерные массивы, которые хранят ссылки. Ссылки в них хранятся разные.  <br>`false` (содержимое массивов неравно)|
|```java<br>int[][] x1 = {{1, 2, 3}, {4, 5, 6}};<br>int[][] x2 = {{1, 2, 3}, {4, 5, 6}};<br>Arrays.deepEquals(x1, x2);<br>```|`true` (содержимое массивов равно)|

8. **Arrays.fill()**
заполняет переданный массив переданным значением. Вот как это выглядит:

```java
Arrays.fill(имя, значение)
```

И код из примера выше можно сделать немного компактнее и понятнее:

```java
int[] x = new int[100];
Arrays.fill(x, 999);
```

А еще с помощью метода `Arrays.fill()` можно заполнить определенным значением не весь массив, а его часть:

```java
Arrays.fill(имя, первый, последний, значение)
```

Где первый и последний — это номера первой и последней ячеек, которые нужно заполнить.

По старой доброй традиции Java, последний элемент не входит в диапазон.

Пример:

|   |   |
|---|---|
|```java<br>int[] x = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br><br>Arrays.fill(x, 3, 7, 999);<br><br><br>String str = Arrays.toString(x);<br>```|Заполняем ячейки `x[3]`, `x[4]`, `x[5]`, `x[6]` значениями `999`. Нумерация ячеек массива с нуля!  <br>  <br>Переменная `str` содержит значение:  <br><br>```<br>"[1, 2, 3, 999, 999, 999, 999, 8, 9, 10]"<br>```|

Метод `Arrays.fill()` работает только с одномерными массивами. Если в него передать двумерный массив, он будет обработан как одномерный, со всеми вытекающими последствиями.

9. **Arrays.binarySearch()**
умеет искать заданное значение в массиве
Минусом такого подхода является то, что массив предварительно нужно отсортировать
Вот как выглядит его вызов:

```java
int index = Arrays.binarySearch(имя, значение);
```

Где `имя` — это имя массива, который нужно передать уже отсортированным (например, с помощью функции `Arrays.sort()`). `значение` — это тот элемент, который ищется в массиве. Метод возвращает результат — индекс искомого элемента в массиве (номер ячейки массива).

Примеры:

|   |   |
|---|---|
|```java<br>int[] x = {11, -2, 3, 0, 999, -20, 8, -20, 99, -20};<br>Arrays.sort(x);<br><br>int index1 = Arrays.binarySearch(x, 0);<br>int index2 = Arrays.binarySearch(x, -20);<br>int index3 = Arrays.binarySearch(x, 99);<br>int index4 = Arrays.binarySearch(x, 5);<br>```|`x` содержит:  <br><br>```<br>{-20, -20, -20, -2, 0, 3, 8, 11, 99, 999}<br>```<br><br>  <br>`4`  <br>`1` (также подходили индексы `0` и `2`)  <br>`8`  <br>`-7`|

Если искомых элементов в массиве **несколько**, просто вернется номер одного из них (нет гарантий, что это будет, допустим, самый первый или наоборот — самый последний из одинаковых элементов).

Если элемент в массиве **не найден, индекс будет отрицательным.**

