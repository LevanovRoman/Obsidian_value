Чтобы работать с _PostgreSQL_ из _Python_, воспользуемся пакетом _psycopg_2. Именно его _Django_ по умолчанию использует «под капотом», когда работает с этой СУБД. Чтобы установить этот пакет, создайте себе виртуальное окружение и выполните в нём команду `pip install psycopg2-binary`. Теперь вы можете попробовать выполнить из интерпретатора следующий код, чтобы проверить работу с БД (объяснения к каждой строчке приведены в комментарии над ней):

Импортировать пакет psycopg2
import psycopg2

Открыть подключение к базе.
Обратите внимание на синтаксис строки с информацией о БД:
если вы меняли настройки своей БД, то и здесь им придётся
указать соответствующие.
Кстати, таких подключений можно открывать сколько угодно:
вдруг у вашего приложения данные распределены
по нескольким базам?
conn = psycopg2.connect("dbname=postgres user=postgres")

Создать «курсор» на подключении к базе.
Курсоры используются для представления
сессий подключения к БД.
cur = conn.cursor()

Выполнить команду напрямую.
cur.execute(
    "CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);"
)

Выполнить команду, не заботясь о корректном синтаксисе
представления данных: psycopg2 всё сделает за нас.
cur.execute(
    "INSERT INTO test (num, data) VALUES (%s, %s)",
    (100, "abc'def")
)

Выполнить команду
cur.execute("SELECT * FROM test;")
Но как получить результат её выполнения?..

А вот так. fetchone — «принести» одну строчку результата,
fetchall — все строчки.
cur.fetchone()

Завершить транзакцию
conn.commit()
Закрыть курсор
cur.close()
Закрыть подключение
conn.close()

Итак, мы видим, что работа с СУБД не напрямую, а с помощью библиотеки _psycopg_2 сразу даёт нам несколько преимуществ:

- мы можем использовать курсоры для работы с БД в нескольких сессиях;
- мы можем меньше заботиться о правильном синтаксисе запроса и автоматически получать данные из БД не просто в виде строки, но сразу в типах данных _Python_.