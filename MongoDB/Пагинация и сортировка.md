MongoDB представляет ряд функций, которые помогают управлять выборкой из бд. Одна из них - функция limit. Она задает максимально допустимое количество получаемых документов. Количество передается в виде числового параметра. Например, ограничим выборку тремя документами:

|   |   |
|---|---|
|1|`db.users.find().limit(3)`|

В данном случае мы получим первые три документа (если в коллекции 3 и больше документов). Но что, если мы хотим произвести выборку не сначала, а пропустив какое-то количество документов? В этом нам поможет функция skip. Например, пропустим первые три записи:

|   |   |
|---|---|
|1|`db.users.find().skip(3)`|

Комбинируя обе функции, мы можем получить определенное количество документов, начиная с определенного документа. Например, выберем документы с 4 по 6:

|   |   |
|---|---|
|1|`db.users.find().skip(3).limit(3)`|

MongoDB предоставляет возможности отсортировать полученный из бд набор данных с помощью функции sort. Передавая в эту функцию значения 1 или -1, мы можем указать в каком порядке сортировать: по возрастанию (1) или по убыванию (-1). Во многом эта функция по действию аналогична выражению `ORDER BY` в SQL. Например, сортировка по возрастанию по полю `name`:

|   |   |
|---|---|
|1|`db.users.find().sort({name: 1})`|

Например, выведем из бд только значения поля "name", отсортировав их по возрастанию:

test> db.users.find({}, {name:1, _id: 0}).sort({name: 1})
[
  { name: 'Bill' },
  { name: 'Bob' },
  { name: 'Sam' },
  { name: 'Tim' },
  { name: 'Tom' },
  { name: 'Tom' },
  { name: 'Tom' },
  { name: 'Tom' },
  { name: 'Tomas' }
]
test>

### Оператор $slice

$slice является в некотором роде комбинацией функций `limit` и `skip`. Но в отличие от них $slice может работать с массивами.

Оператор `$slice` имеет две формы:

|   |   |
|---|---|
|1<br><br>2|`$slice: limit`<br><br>`$slice: skip, limit`|

Параметр `limit` указывает на общее количество возвращаемых документов. Параметр `skip` указывает на смещение относительно начала (как функция skip).

Например, в каждом документе определен массив languages для хранения языков, на которых говорит человек. Их может быть и 1, и 2, и 3 и более. И допустим, ранее мы добавили следующий объект:

|   |   |
|---|---|
|1|`db.users.insertOne({``"name"``:` `"Tom"``,` `"age"``: 32, languages: [``"english"``,` `"german"``,` `"spanish"``]})`|

И мы хотим при выводе документов сделать так, чтобы в выборку попадал только один язык из массива languages, а не весь массив:

|   |   |
|---|---|
|1|`db.users.find ({name:` `"Tom"``}, {languages: {$slice : 1}})`|

Данный запрос при извлечении документа оставит в результате только первый язык из массива languages, то есть в данном случае english.

test> db.users.find ({name: "Tom"}, {languages: {$slice : 1}})
[
  {
    _id: ObjectId("62e3c70079a0a7792a9de20c"),
    name: 'Tom',
    age: 32,
    languages: [ 'english' ]
  }
]
test>

Обратная ситуация: нам надо оставить в массиве также один элемент, но не с начала, а с конца. В этом случае необходимо передать в параметр отрицательное значение:

|   |   |
|---|---|
|1|`db.users.find ({name:` `"Tom"``}, {languages: {$slice : -1}});`|

Теперь в массиве окажется "spanish", так как он первый с конца в добавленном элементе.

Используем сразу два параметра:

|   |   |
|---|---|
|1|`db.users.find ({name:` `"Tom"``}, {languages: {$slice : [-2, 1]}});`|

Первый параметр говорит начать выборку элементов с конца (так как отрицательное значение), то есть выборка идет начиная со второго элемента с конца, а второй параметр указывает на количество возвращаемых элементов массива. В итоге в массиве language окажется "german"
