> **Dockerfile** - это обычный конфигурационный файл, описывающий пошаговое создание среды вашего приложения. В этом файле подробно описывается, какие команды будут выполнены, какие образы задействованы, и какие настройки будут применены. А движок _Docker-а_ при запуске уже распарсит этот файл (именуемый как **Dockerfile**), и создаст из него соответствующий образ _(Image)_, который был описан.
> 
> К примеру, если вы разрабатывали приложение на _php7.2_, и использовали _ElasticSearch 9_ версии, и сохранили это в _Dockerfile_-е, то другие пользователи, которые запустят образ используя ваш _Dockerfile_, получат ту же среду с _php7.2_ и _ElasticSearch 9_.

С _Dockerfile_ вы сможете подробно описать инструкцию, по которой будет воссоздано конкретное состояние. И делается это довольно-таки просто и интуитивно понятно.

Для просмотра полного списка команд можете перейти по [ссылке](https://docs.docker.com/engine/reference/builder/#from)

- `FROM` — задаёт базовый (родительский) образ.
- `LABEL` — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
- `ENV` — устанавливает постоянные переменные среды.
- `RUN` — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
- `COPY` — копирует в контейнер файлы и папки.
- `ADD` — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
- `CMD` — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`.
- `WORKDIR` — задаёт рабочую директорию для следующей инструкции.
- `ARG` — задаёт переменные для передачи Docker во время сборки образа.
- `ENTRYPOINT` — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.
- `EXPOSE` — указывает на необходимость открыть порт.
- `VOLUME` — создаёт точку монтирования для работы с постоянным хранилищем.

FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
ENV ADMIN="jeff" 
RUN apk update && apk upgrade && apk add bash 
COPY . ./app 
ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 \ /my_app_directory
RUN ["mkdir", "/a_directory"] 
CMD ["python", "./my_script.py"]
### Инструкция ENV
Инструкция [ENV](https://docs.docker.com/engine/reference/builder/#env) позволяет задавать постоянные переменные среды, которые будут доступны в контейнере во время его выполнения. В предыдущем примере после создания контейнера можно пользоваться переменной `ADMIN`.  
  
Инструкция `ENV` хорошо подходит для задания констант. Если вы используете некое значение в Dockerfile несколько раз, скажем, при описании команд, выполняющихся в контейнере, и подозреваете, что, возможно, вам когда-нибудь придётся сменить его на другое, его имеет смысл записать в подобную константу.  
  
Надо отметить, что в файлах Dockerfile часто существуют разные способы решения одних и тех же задач. Что именно использовать — это вопрос, на решение которого влияет стремление к соблюдению принятых в среде Docker методов работы, к обеспечению прозрачности решения и его высокой производительности. Например, инструкции `RUN`, `CMD` и `ENTRYPOINT` служат разным целям, но все они используются для выполнения команд.

### Инструкция RUN
Инструкция [RUN](https://docs.docker.com/engine/reference/builder/#run) позволяет создать слой во время сборки образа. После её выполнения в образ добавляется новый слой, его состояние фиксируется. Инструкция `RUN` часто используется для установки в образы дополнительных пакетов. В предыдущем примере инструкция `RUN apk update && apk upgrade` сообщает Docker о том, что системе нужно обновить пакеты из базового образа. Вслед за этими двумя командами идёт команда `&& apk add bash`, указывающая на то, что в образ нужно установить bash.  
  
То, что в командах выглядит как `apk` — это сокращение от [Alpine Linux package manager](https://www.cyberciti.biz/faq/10-alpine-linux-apk-command-examples/) (менеджер пакетов Alpine Linux). Если вы используете базовый образ какой-то другой ОС семейства Linux, тогда вам, например, при использовании Ubuntu, для установки пакетов может понадобиться команда вида `RUN apt-get`. 
  
Инструкция `RUN` и схожие с ней инструкции — такие, как `CMD` и `ENTRYPOINT`, могут быть использованы либо в exec-форме, либо в shell-форме. Exec-форма использует синтаксис, напоминающий описание JSON-массива. Например, это может выглядеть так: `RUN ["my_executable", "my_first_param1", "my_second_param2"]`.  
  
В предыдущем примере мы использовали shell-форму инструкции RUN в таком виде: `RUN apk update && apk upgrade && apk add bash`.  
  
Позже в нашем Dockerfile использована exec-форма инструкции `RUN`, в виде `RUN ["mkdir", "/a_directory"]` для создания директории. При этом, используя инструкцию в такой форме, нужно помнить о необходимости оформления строк с помощью двойных кавычек, как это принято в формате JSON.

### Инструкция COPY
Инструкция [COPY](https://docs.docker.com/engine/reference/builder/#copy) представлена в нашем файле так: `COPY . ./app`. Она сообщает Docker о том, что нужно взять файлы и папки из локального контекста сборки и добавить их в текущую рабочую директорию образа. Если целевая директория не существует, эта инструкция её создаст.

### Инструкция ADD
Инструкция [ADD](https://docs.docker.com/engine/reference/builder/#add) позволяет решать те же задачи, что и `COPY`, но с ней связана ещё пара вариантов использования. Так, с помощью этой инструкции можно добавлять в контейнер файлы, загруженные из удалённых источников, а также распаковывать локальные .tar-файлы. 
  
В этом примере инструкция `ADD` была использована для копирования файла, доступного по URL, в директорию контейнера `my_app_directory`. Надо отметить, однако, что [документация Docker](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) не рекомендует использование подобных файлов, полученных по URL, так как удалить их нельзя, и так как они увеличивают размер образа.  
  
Кроме того, [документация](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy) предлагает везде, где это возможно, вместо инструкции `ADD` использовать инструкцию `COPY` для того, чтобы сделать файлы Dockerfile понятнее.   
  
Обратите внимание на то, что инструкция `ADD` содержит символ разрыва строки — `\`. Такие символы используются для улучшения читабельности длинных команд путём разбиения их на несколько строк.

### Инструкция CMD
Инструкция [CMD](https://docs.docker.com/engine/reference/builder/#cmd) предоставляет Docker команду, которую нужно выполнить при запуске контейнера. Результаты выполнения этой команды не добавляются в образ во время его сборки. В нашем примере с помощью этой команды запускается скрипт `my_script.py` во время выполнения контейнера.  
  
Вот ещё кое-что, что нужно знать об инструкции `CMD`:  
  

- В одном файле Dockerfile может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней.
- Инструкция `CMD` может иметь exec-форму. Если в эту инструкцию не входит упоминание исполняемого файла, тогда в файле должна присутствовать инструкция `ENTRYPOINT`. В таком случае обе эти инструкции должны быть представлены в формате `JSON`.
- Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в Dockerfile.


FROM python:3.7.2-alpine3.8 
LABEL maintainer="jeffmshale@gmail.com" 
  Устанавливаем зависимости
RUN apk add --update git 
  Задаём текущую рабочую директорию 
WORKDIR /usr/src/my_app_directory 
  Копируем код из локального контекста в рабочую директорию образа 
COPY . .
  Задаём значение по умолчанию для переменной 
ARG my_var=my_default_value 
  Настраиваем команду, которая должна быть запущена в контейнере во время его выполнения 
ENTRYPOINT ["python", "./app/my_script.py", "my_var"] 
  Открываем порты EXPOSE 8000 # Создаём том для хранения данных 
VOLUME /my_volume

Например, инструкцию `RUN` в Dockerfile можно использовать для установки списка пакетов с помощью `pip`. Если вы так поступаете — объедините все команды в одну инструкцию и разделите её символами разрыва строки с помощью символа `\`. Благодаря такому подходу файлы будут выглядеть аккуратно и это приведёт к добавлению в образ меньшего количества слоёв, чем было бы добавлено при использовании нескольких инструкций `RUN`.  
  
Кроме того, для установки нескольких пакетов можно поступить и по-другому. Их можно перечислить в файле и передать менеджеру пакетов этот файл с помощью `RUN`. Обычно таким файлам дают имя `requirements.txt`.

### Инструкция WORKDIR
Инструкция [WORKDIR](https://docs.docker.com/v17.09/engine/reference/builder/#workdir) позволяет изменить рабочую директорию контейнера. С этой директорией работают инструкции `COPY`, `ADD`, `RUN`, `CMD` и `ENTRYPOINT`, идущие за `WORKDIR`. Вот некоторые особенности, касающиеся этой инструкции:  

- Лучше устанавливать с помощью `WORKDIR` абсолютные пути к папкам, а не перемещаться по файловой системе с помощью команд `cd` в Dockerfile.
- Инструкция `WORKDIR` автоматически создаёт директорию в том случае, если она не существует.
- Можно использовать несколько инструкций `WORKDIR`. Если таким инструкциям предоставляются относительные пути, то каждая из них меняет текущую рабочую директорию.

### Инструкция ARG
Инструкция [ARG](https://docs.docker.com/engine/reference/builder/#arg) позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки. Значение для переменной по умолчанию можно представить в Dockerfile. Например: `ARG my_var=my_default_value`.  
  
В отличие от `ENV`-переменных, `ARG`-переменные недоступны во время выполнения контейнера. Однако `ARG`-переменные можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа. А `ENV`-переменные уже будут доступны в контейнере во время его выполнения. Подробности о такой методике работы с переменными можно почитать [здесь](https://vsupalov.com/docker-build-time-env-values/).

### Инструкция ENTRYPOINT
Инструкция [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) позволяет задавать команду с аргументами, которая должна выполняться при запуске контейнера. Она похожа на команду `CMD`, но параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки.  
  
Вместо этого аргументы командной строки, передаваемые в конструкции вида `docker run my_image_name`, добавляются к аргументам, задаваемым инструкцией `ENTRYPOINT`. Например, после выполнения команды вида `docker run my_image bash` аргумент `bash` добавится в конец списка аргументов, заданных с помощью `ENTRYPOINT`. Готовя Dockerfile, не забудьте об инструкции `CMD` или `ENTRYPOINT`.  
  
В документации к Docker есть несколько рекомендаций, касающихся того, какую инструкцию, `CMD` или `ENTRYPOINT`, стоит выбрать в качестве инструмента для выполнения команд при запуске контейнера:    

- Если при каждом запуске контейнера нужно выполнять одну и ту же команду — используйте `ENTRYPOINT`.
- Если контейнер будет использоваться в роли приложения — используйте `ENTRYPOINT`.
- Если вы знаете, что при запуске контейнера вам понадобится передавать ему аргументы, которые могут перезаписывать аргументы, указанные в Dockerfile, используйте `CMD`.
  
В нашем примере использование инструкции `ENTRYPOINT ["python", "my_script.py", "my_var"]` приводит к тому, что контейнер, при запуске, запускает Python-скрипт `my_script.py` с аргументом `my_var`. Значение, представленное `my_var`, потом можно использовать в скрипте с помощью [argparse](https://docs.python.org/3/library/argparse.html). Обратите внимание на то, что в Dockerfile переменной `my_var`, до её использования, назначено значение по умолчанию с помощью `ARG`. В результате, если при запуске контейнера ему не передали соответствующее значение, будет применено значение по умолчанию.  
  
Документация Docker рекомендует использовать exec-форму `ENTRYPOINT`: `ENTRYPOINT ["executable", "param1", "param2"]`.

### Инструкция EXPOSE
Инструкция [EXPOSE](https://docs.docker.com/engine/reference/builder/#expose) указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Она, скорее, играет роль документации к образу, средством общения того, кто собирает образ, и того, кто запускает контейнер.  
  
Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run` с ключом `-p`. Если использовать ключ в виде `-P` (с заглавной буквой `P`), то открыты будут все порты, указанные в инструкции `EXPOSE`.

### Инструкция VOLUME
Инструкция [VOLUME](https://docs.docker.com/engine/reference/builder/#volume) позволяет указать место, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами.


